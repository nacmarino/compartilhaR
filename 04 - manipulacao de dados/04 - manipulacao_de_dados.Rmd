---
title: "Manipulação de Dados"
subtitle: "Nicholas A. C. Marino"
author: "nac.marino@gmail.com"
date: "github.com/nacmarino/compartilhaR"
output: 
  ioslides_presentation:
    wide: true
---

<style type="text/css">
body, td {
   font-size: 18px;
}
code.r{
  font-size: 16px;
}
pre {
  font-size: 16px
}
h1,h2,h3,h4,h5,h6{
  font-size: 24pt;
}
</style>

## Elementos da Aula

1. [A natureza dos dados](#anchor1)
2. [Métodos orientados ao conteúdo das colunas](#anchor#2)
3. [Métodos orientados à tabela de dados](#anchor3)
4. [De largo para longo, e de volta outra vez](#anchor4)

## A natureza dos dados{#anchor1}

Um dado pode estar em duas diferentes 'fases de maturidade':  
  
1. __Dados brutos (_raw data_):__ são os dados em sua forma mais bruta, recém tabelados, com todos os erros de digitação, de unidade, e etc...  
2. __Dados limpos (_tidy data_):__ são os dados em uma forma limpa. Aqui, os dados brutos foram checados e corrigidos, erros de digitação desfeitos, unidades transformadas e etc. Todo e qualquer nova variável que pode ser gerada com os dados brutos está aqui.  

<p align="center">
<img src="figures/data1.png" height="250px"></img>
</p>

## A natureza dos dados

Além disso, mesmo os dados limpos podem não estar prontos para o uso ou, ainda, existirem dados derivados que serão o enfoque do seu trabalho.

3. __Dados para análise:__ normalmente você não precisa de todos os dados que você limpou e/ou alguns dos dados úteis para a análise podem estar em outras tabelas. Assim, ao invés de começar toda a análise de dados removendo àquelas informações que não são úteis e buscando àquelas outras que são, você também pode criar recortes de dados que serão específicos para certas tarefas.
4. __Dados dos resultados das análises:__ após rodar uma análise você pode exportar os resultados para fora do R. Ao fazer isso, estes dados retornam para a etapa número 1 - você precisa ajeitar os nomes das colunas, casas decimais,...

## A natureza dos dados

<p align="center">
<img src="figures/data2.png" height="350px"></img>
</p>

## A natureza dos dados

Outro ponto importante é que algumas análises exigem que os dados sejam apresentados de uma forma específica, o que também leva à duas formas de apresentar um mesmo dado.

<p align="center">
<img src="figures/formato.png" height="400px"></img>
</p>

## A natureza dos dados {.smaller}

* Uma parte comum e bastante importante em todas essas fases é a manipulação, limpeza e processamento de dados (_tidying data_).  
* É aqui que vamos preparar os dados para o uso em uma análise, para a criação de uma tabela com os resultados que encontramos e, também, para a confecção de figuras.  
* Mas também é onde:
    + Você normalmente faz tudo de forma manual;
    + Você não mantém registro escrito do que está fazendo;
    + Você vai criar múltiplas versões de uma mesma planilha, pois não sabe se as coisas que você está manipulando, mexendo e editando fazem sentido ou estão corretas;
    + Você perde tempo da forma mais repetitiva possível - a não ser que você use uma linguagem de programação! =]  

## Objetivos da manipulação, limpeza e processamento de dados

1. Criar e/ou eliminar novas variáveis (normalmente, nas colunas);  
2. Substituir valores que foram digitados errados;  
3. Substituir palavras e expressões que estejam má digitadas ou onde hajam nomes melhores;  
4. Modificar os nomes das variáveis (normalmente, as colunas);  
5. Modificar os nomes dos níveis das variáveis (normalmente, os valores das linhas de uma determinada coluna);  
6. Separar a informação de uma coluna em duas ou mais;  
7. Rearranjar a ordem das colunas;  
8. Selecionar as colunas que vão compor os dados que serão analisados;  
9. Passar os dados de um formato longo para um formato largo (e vice-versa);  
10. Juntar dados que estão separados em planilhas diferentes;  
11. Remover `NA`s;
12. Selecionar sub-conjuntos dos dados para destinações diferentes (e.g., diferentes pedaços de _tidy data_);
13. Fazer algumas transformações na estrutura original dos dados para criar um _tidy data_ mais condizente com o que você vai precisar na hora das análises.  

## `tidyverse`

* Existem muitas funções na `base` do R que podem ser utilizadas para a manipulação, limpeza e processamento de dados.
* No entanto, muitos dos pacotes mais úteis para estas tarefas estão organizados dentro de um pacote 'guarda-chuva', chamado `tidyverse`.

```{r warning=FALSE, message=FALSE}
library(tidyverse)
tidyverse_packages()
```

## Exercício 1

* Vamos utilizar todas as seis tabelas de dados abaixo nas tarefas e exercícios a seguir.  
a. Importe para o R as seguintes tabelas:
    + __dados dos projetos.csv__, e atribua este arquivo ao objeto __projetos__;
    + __publicacoes.xls__, e atribua este arquivo ao objeto __publicacoes__;
    + __revistas.xlsx__, e atribua este arquivo ao objeto __revistas__.
b. Também, carregue dois conjuntos de dados que estão disponíveis dentro de pacotes:
    + __varechem__ e __varespec__, disponíveis no pacote `vegan`;
    + __gapminder__ disponível no pacote `gapminder`.

```{r message=FALSE, warning=FALSE, echo=FALSE}
library(vegan)
library(gapminder)
library(readxl)
data("varechem")
data("varespec")
projetos <- read_csv(file = "../99 - dados para exemplos/dados dos projetos.csv")
publicacoes <- read_excel(path = "../99 - dados para exemplos/publicacoes.xls", na = "NA")
revistas <- read_excel(path = "../99 - dados para exemplos/revistas.xlsx", na = "NA")
```

## Métodos orientados ao conteúdo das colunas{#anchor2}

* É muito comum que cometamos erros de digitação ao preenchermos uma tabela e uma vez que estes erros sejam detectados, normalmente consertamos eles manualmente na tabela de dados brutos.
* No entanto, é bastante preferível que estes consertos sejam realizados através da própria linguagem de programação, a fim de que toda e qualquer alteração e editoração que você tenha feito a um conjunto de dados fique registrado e você não se esqueça no futuro.
* Outra vantagem disso é que qualquer alteração futura que precise ser feita será muito mais fácil, uma vez que apenas será necessário mudar uma única linha de comando - ao invés de repetir manualmente todas as etapas da manipulação, limpeza e processamento de dados.
* Este processo também é útil quando queremos criar novas variáveis baseado nos valores daquelas que já existem.

## Substituição de valores

* Duas funções bastante úteis para modificar valores são `sub` e `gsub`.  

```{r}
sub(pattern = "é", replacement = "e", x = "América do Norte")
sub(pattern = "E", replacement = "e", x = "AmErica do NortE")
gsub(pattern = "E", replacement = "e", x = "AmErica do NortE")
```

## Substituição de valores

* Estas funções também podem ser utilizadas para remover espaços e outros caracteres (como `.`, `,`, `-`, e etc).

```{r}
gsub(pattern = "  ", replacement = " ", x = "Rio  de  Janeiro")
sub(pattern = "/", replacement = " ", x = "PPGE/UFRJ")
sub(pattern = "-", replacement = " ", x = c("Pé-de-moleque", "PPGE-UFRJ"))
```

## Substituição de valores {.smaller}

* Também podemos empregar estas funções em vetores e colunas.
* No exemplo abaixo, utilizamos a função `unique` para termos uma noção de quais são os valores únicos que aparecem dentro da coluna __Chamada__ do objeto __projetos__ - você consegue encontrar algum erro em algum dos elementos?

```{r}
unique(x = projetos$Chamada)
```

## Exercício 2

a. Substitua o erro de digitação que você encontrou pela grafia certa da palavra.  
b. Avalie se esta substiuição corrigiu esta entrada na coluna __Chamada__ do objeto __projetos__.  
c. Caso não tenha sido corrigida, o que você acha que aconteceu? Como podemos realizar essa correção?

```{r echo=FALSE}
projetos$Chamada <- sub(pattern = "Atletica", replacement = "Atlantica", x = projetos$Chamada)
```

## Edição de valores em um vetor

* Valores e nomes de variáveis com espaço, muito longos, com caracteres especiais, em caixa alta e etc, podem causar erros durante a indexação e operação de algumas funções. Portanto, é sempre desejável que simplifiquemos estes nomes e tornemos eles consistentes, para evitar possíveis dores de cabeça. Para isso, quatro funções podem ser bastante úteis: `tolower`, `toupper`, `make.names` e `abbreviate`.

```{r}
## vamos criar um vetor com as 10 primeiras publicacoes que aparecem na coluna Publicacao do objeto revistas
exemplo <- revistas$Publicacao[1:10]
exemplo
```

## Edição de valores em um vetor

```{r eval=FALSE}
# tolower faz com que todos os caracteres fiquem em caixa baixa
tolower(exemplo)
# toupper faz com que todos os caracteres fiquem em caixa alta
toupper(exemplo)
# make.names faz com que os nomes das colunas mudem para um formato mais amigável a um computador 
make.names(exemplo)
# e, se você achar que os nomes estão muito longos, podemos usar a função abbreviate
abbreviate(exemplo)
```

## Exercício 3

* Observe que os nomes das colunas do objeto __projetos__ não são de todo consistentes. Você conseguiria modificar o nome dessas colunas, fazendo com que todos os caracteres ficassem em caixa baixa? Dica: utilize `names(projetos)` ou `colnames(projetos)` para visualizar o nome das colunas desse `data.frame`.

```{r echo=FALSE}
names(projetos) <- tolower(names(projetos))
```

## Combinando vetores

* Você também pode unir informações presentes em dois ou mais vetores (ou colunas) em um único elemento, utilizando as funções `paste` e `paste0`. Como exemplo, vamos unir a sigla da Unidade da Federação com o nome da Cidade que estão no objeto __projetos__.

```{r eval=FALSE}
## compare as formas abaixo
paste(projetos$cidade, projetos$uf)
paste(projetos$cidade, projetos$uf, sep = "/")
paste0(projetos$cidade, projetos$uf)
paste0(projetos$cidade, "/", projetos$uf)
```

## Exercício 4

* De que forma podemos criar o `data.frame` abaixo? (apenas as primeiras linhas são apresentadas aqui por conta do tamanho)

```{r echo=FALSE}
localidade <- data.frame(id_coordenador = projetos$id_coordenador, localidade = paste0(projetos$cidade, "/", projetos$uf))
localidade[1:12,]
```

## Edição de vetores baseado em lógica

* Finalmente, também podemos editar e alterar os valores de uma coluna baseado em testes e argumentos lógicos.
* Uma função importante neste sentido é o `ifelse`.

```{r}
## um vetor contendo o sexo de 10 pessoas
sexo <- rep(x = c("M", "F"), each = 5)
sexo

## substituindo
ifelse(test = sexo == "M", yes = "masculino", no = "feminino")
```

## Exercício 5

* Adicione uma coluna ao objeto __revistas__ que especifique se a revista em questão é nacional ou internacional.  

## Edição de vetores baseado em lógica

* Mas o que acontece se tivéssemos três categorias diferentes de sexo?

```{r}
## um vetor contendo o sexo de 15 pessoas
sexo <- rep(x = c("M", "F", "ND"), each = 5)
sexo
```

```{r eval=FALSE}
## substituindo
ifelse(test = sexo == "M", yes = "masculino", no = "feminino")
```

## Edição de vetores baseado em lógica

* Cada elemento de um vetor que não passa no teste do `ifelse` recebe o valor que determinamos. Portanto, quando temos um vetor com múltiplos valores e queremos substituir apenas um deles devemos fazer essa operação em cadeia.

```{r results='hide'}
# se o resultado for verdadeiro substitua por 'masculino', caso contrario, substitua pelo valor de sexo naquela posicao
(sexo <- ifelse(test = sexo == "M", yes = "masculino", no = sexo))

# se o resultado for verdadeiro substitua por 'feminino', caso contrario, substitua pelo valor de sexo naquela posicao
(sexo <- ifelse(test = sexo == "F", yes = "feminino", no = sexo))

# se o resultado for verdadeiro substitua por 'feminino', caso contrario, substitua pelo valor de sexo naquela posicao
(sexo <- ifelse(test = sexo == "ND", yes = "não determinado", no = sexo))
```

## Exercício 6

* Você consegue realizar a mesma operação que acabamos demonstrar sem criar um objeto a cada etapa?

```{r}
## um vetor contendo o sexo de 15 pessoas
sexo <- rep(x = c("M", "F", "ND"), each = 5)
sexo
```

## Editando todo o conteúdo das colunas de uma tabela

* O `ifelse` também pode ser aplicado à toda a tabela de dados, o que pode nos ajudar a transformar uma matriz de abundância em uma de presenca/ausência.

```{r eval=FALSE}
ifelse(test = varespec > 0, yes = 1, no = 0)
```

```{r echo=FALSE}
ifelse(test = varespec > 0, yes = 1, no = 0)[1:10, 1:8]
```

## Exercício 7

* Uma tarefa muito comum para quem trabalha com ecologia de comunidades é quantificar a abundância total e a riqueza de espécies em uma dada comunidade. Nesse sentido, você poderia criar um `data.frame` com estas duas quantidades para cada comunidade apresentada no conjunto de dados `varespec`?  
    + Dica: veja o arquivo de ajuda das funções `colSums` e `rowSums`.  

## Métodos orientados à tabela de dados {#anchor3} {.smaller}

* As funções apresentadas anteriormente são úteis para realizar algumas manipulações básicas e mais comuns do conteúdo de um tabela. No entanto, existe muitas outras coisas que precisamos fazer durante a manipulação, limpeza e processamento de dados, onde muitas delas são feitas de forma complexa ou pouco intuitiva através das funções da `base` do R.
* Algumas dessas tarefas são:
    + Renomear o nome de uma coluna específica (na `base`, indexação);
    + Ordenar uma tabela de acordo com uma ou mais colunas (na `base`, indexação + `sort` e/ou `order`);
    + Selecionar algumas colunas específicas ou mudar a ordem delas (na `base`, indexação ou escrever o nome de cada uma - entre aspas);
    + Filtrar uma tabela de dados de acordo com critérios lógicos (na `base`, indexação por lógica ou `subset`);
    + Adicionar uma nova coluna a um conjunto de dados (na `base`, indexação);
    + Realizar uma operação para cada nível de uma categoria que defina as observações (na `base`, loop ou funções loop (`by`, `apply`, `lapply`,...));
    + Separar as informações de uma coluna em múltiplas colunas (na `base`, `strsplit` + `unlist` + `rbind.data.frame`);
    + Transformar uma tabela de dados do formato largo para o formato longo e vice-versa.
    
## Métodos orientados à tabela de dados {.smaller}

* Note que todas essas ações podem ser definidas por __verbos__, que foram implementas através dos pacotes `dplyr` e `tidyr` no `tidyverse`.
    + `rename`: renomeia as colunas da tabela;
    + `arrange`: ordena as linhas de uma tabela de acordo com uma condição;  
    + `select`: seleciona uma ou mais colunas de acordo com seu nome ou com um padrão;
    + `filter`: filtra as linhas de acordo com uma ou mais condições;  
    + `mutate`: adiciona novas variáveis à tabela;  
    + `group_by`: agrupa observações antes de realizar opereações;    
    + `summarise`: sumariza múltiplos valores para um único;   
    + `separate`: separa uma coluna em múltiplas colunas;  
    + `spread`: transforma uma tabela do __formato longo para o formato largo__;  
    + `gather`: transforma uma tabela do __formato largo para o formato longo__.

## Funcionamento geral do verbos do `tidyverse`

* Unidade primária de manipulação é o `data.frame` e ou `tibble`, e as colunas presentes neles;
* Todo o verbo é interpretado através de _lazy evaluation_: a primeira coisa que você fornece para a função é o conjunto de dados; a partir daí, a própria função entende que tudo o que você for fazer é em referência às informações que estão ali - elimina a necessidade de indexação.
* A idéia geral aqui é encurtar o espaço entre o que você quer fazer e o resultado (ou seja, entre a pergunta e a resposta), sem importar o tamanho do conjunto de dados.
* Para provar estes pontos, vamos utilizar o conjunto de dados `gapminder` que carregamos no início da aula.

## `gapminder`

```{r}
gapminder
```

## `rename`

Utilizada para renomear colunas específicas, contornando a necessidade de indexação. 

```{r}
rename(.data = gapminder, pais = country, continente = continent, ano = year)
```

## `arrange`

Utilizada para ordernar as linhas de uma tabela em ordem crescente ou decrescente.  

```{r}
arrange(.data = gapminder, year)
```

## `arrange`

Utilizada para ordernar as linhas de uma tabela em ordem crescente ou decrescente. 

```{r}
arrange(.data = gapminder, desc(year))
```

## `arrange`

Pode comportar tantas colunas quantas aquelas que você desejar.

```{r}
arrange(.data = gapminder, desc(year), lifeExp)
```

## Exercício 8

a. Qual foi o projeto que mais gastou recursos dentre aqueles financiados pelo CNPq?
b. Qual foi o coordenador que terminou o doutorado há mais tempo?
c. Qual o coordenador que tem o maior índice H e não fez pós-doutorado?

## `select`

Utilizada para selecionar uma ou mais colunas de acordo com seu nome.

```{r}
# somente o pais, ano e gdp per capita
select(.data = gapminder, country, year, gdpPercap)
```

## `select`

Utilizada para selecionar uma ou mais colunas de acordo com seu nome.

```{r}
# apenas algumas variáveis e reordenando elas
select(.data = gapminder, gdpPercap, country:lifeExp)
```

## `select`

Também pode ser utilizada para selecionar colunas baseado em um padrão específico, utilizando os argumentos auxiliares:  
  
+ `starts_with()`: seleciona colunas que comecem com um certo padrão em seu nome;
+ `ends_with()`: seleciona colunas que terminem com um certo padrão em seu nome;
+ `contains()`: seleciona colunas que contenham um certo padrão em seu nome.
    
## Exercício 9

* Do conjunto de dados do `gapminder`:
    + Remova apenas a coluna `country` de `gapminder`;
    + Selecione as colunas `continent`, `year` e `pop`;
    + Com o resultado da última operação, ordene as linhas de acordo com a ordem decrescente dos anos;
    + Além de ordenar as linhas pela ordem crescente dos continentes, ordene agora também o tamanho da população.  
* Do conjunto de dados dos projetos, selecione a coluna com o ID do coordenador do projeto e todas as colunas que representam de recursos gastos em cada projeto.  

## `filter`

Utilizada para filtrar uma tabela de acordo com as condições que você determina.

```{r}
# apenas os dados do Brasil
filter(.data = gapminder, country == "Brazil")
```

## `filter`

Utilizada para filtrar uma tabela de acordo com as condições que você determina.

```{r}
# dados das Americas, apenas os 20 últimos anos
filter(.data = gapminder, continent == "Americas", year > 1996)
```

## `filter`

Utilizada para filtrar uma tabela de acordo com as condições que você determina.

```{r}
# dados das Americas e Europa, apenas os 20 últimos anos
filter(.data = gapminder, continent == "Americas" | continent == "Europe", year > 1996)
```

## `filter`

Podemos utilizar o argumento lógico `%in%` para selecionar múltiplos elementos de uma mesma coluna.

```{r}
# dados das Americas Europa e Oceania, apenas os 20 últimos anos
filter(.data = gapminder, continent %in% c("Americas", "Europe", "Oceania"), year > 1996)
```

## `filter` {.smaller}

E podemos criar uma função para fazer o inverso do `%in%`!

```{r}
## criando a função
`%nin%` <- Negate(f = `%in%`)

## removendo os dados das Americas, Europa e Oceania
filter(.data = gapminder, continent %nin% c("Americas", "Europe", "Oceania"), year > 1996)
```

## Exercício 10

* Quais foram os projetos financiados no estado do Rio de Janeiro?
* Quais os projetos financiados no estado do Rio de Janeiro foram coordenados por mulheres?
* Onde estão localizados os bolsistas de produtividade 1C ou 1D que mais gastaram recursos?

## `mutate`

Cria uma nova coluna na tabela de dados, inclusive usando as próprias colunas que estão sendo criadas dentro da função naquele momento.

```{r}
mutate(.data = gapminder, log_gdp = log(gdpPercap), exp_gdp = exp(log_gdp))
```

## `transmute`

Similar ao `mutate`, mas elimina todas as outras colunas ao retornar o resultado

```{r}
transmute(.data = gapminder, log_gdp = log(gdpPercap), exp_gdp = exp(log_gdp))
```

## Exercício 11

* Crie uma nova coluna na tabelas __processos__ que seja a combinação das colunas `cidade` e `uf`.  

## `group_by`

Agrupa as observações de acordo com os níveis de uma ou mais variáveis presentes nas colunas. É excelente para ser combinado com outras funções.

```{r}
group_by(.data = gapminder, continent)
```

## `group_by` + `filter`

```{r}
## quais sao os paises em cada continente que tiveram menor expectativa de vida em toda a serie
filter(.data = group_by(.data = gapminder, continent), lifeExp == min(lifeExp))
```

## Exercício 12

* Quais são os coordenadores estrangeiros e brasileiros que tem indice H menor do que 15 e se terminaram o doutorado antes de 1990?
* Quais são os coordenadores que mais gastaram recursos por classe de bolsa de produtividade?

## `group_by` + `summarise`

Uma das grandes vantagens do `group_by` é observada quando combinamos ele com a função `summarise`, que aplica uma mesma função para cada nível da variável agrupadora e retorna uma tabela com o sumário estatístico.

```{r}
## expectativade vida media por continente
summarise(.data = group_by(.data = gapminder, continent), expectativa_media = mean(lifeExp))
```

## `group_by` + `summarise`

* Podemos agrupar os dados de acordo com várias colunas.
* Para quebrar o agrupamento basta utilizarmos a função `ungroup`.

```{r}
## expectativamente de vida media por continente por ano
summarise(.data = group_by(.data = gapminder, continent, year), expectativa_media = mean(lifeExp))
```

## Exercício 13

* Utilizando o objeto __revistas__, adicione uma coluna indicando se cada revista é nacional ou estrangeira e calcule o índice SJR médio destas duas categorias. 
* Calcule o índice H médio de coordenadores de projetos brasileiros e extrangeiros de acordo com o tipo de bolsa de produtividade recebido, e considerando apenas os coordenadores que terminaram o doutorado após o ano 2000.

## O operador __pipe__: `%>%`

* Em toda língua, todo texto fica difícil de compreender quando emendarmos frases sem adicionar uma pontuação.
* Acabamos de ver isso acontecendo também quando utilizamos a linguagem R, ao utilizarmos resultado de um verbo diretamente no processamento de outro verbo do `tidyverse`.
* Isso faz com que todo o código que escrevamos rapidamente fique complexo demais de se ler ou, ainda, exija a criação de diversas etapas intermediárias.

```{r eval=FALSE}
## muito complexo
summarise(.data = group_by(.data = select(.data = gapminder, country, continent, gdpPercap), continent, country), 
          media_gdp = mean(gdpPercap))

## muito enfadonho
passo1 <- select(.data = gapminder, country, continent, gdpPercap) 
passo2 <- group_by(.data = passo1, continent, country)
passo3 <- summarise(.data = passo2, media_gdp = mean(gdpPercap))
```

## O operador __pipe__: `%>%`

* A fim de descomplicar a escrita do código e fazer com que ele fique mais claro, o operador `pipe` é implementado no ambiente de trabalho quando você carrega o `tidyverse`.
* O operador `pipe`, representado pelo símbolo `%>%`, é implementado especificamente através do pacote `dplyr`.
* O atalho do teclado para o `pipe` é __Control + Shift + M__ (no Windows) ou __Command + Shift + M__ (no MAC).
* Um exemplo do uso do `pipe` no mesmo contexto apresentado no slide anterior:

```{r eval=FALSE}
gapminder %>% 
  select(country, continent, gdpPercap) %>% 
  group_by(continent, country) %>% 
  summarise(media_gdp = mean(gdpPercap))
```

## O operador __pipe__: `%>%`

* O `pipe` funciona potencializando o _lazy evaluation_ nos verbos do `tidyverse`.
* Ele passa o `data.frame`/`tibble` de uma linha de comando ou resultante do processamento de um verbo para o argumento `.data` do verbo que o segue - assim como a pontuação e adjuntos conectam frases no português.

```{r eval=FALSE}
gapminder %>% 
  select(country, continent, gdpPercap) %>% 
  group_by(continent, country) %>% 
  summarise(media_gdp = mean(gdpPercap))
```

## O operador __pipe__: `%>%` {.smaller}

* Como veremos nas outras aulas, o `pipe` também pode ser empregado no processamento de outras funções, incluindo a extração e processamento de resultados de análises.

```{r eval=FALSE}
gapminder %>% 
  group_by(country) %>% 
  summarise(expectativa = mean(lifeExp), gdp = mean(gdpPercap)) %>% 
  lm(gdp ~ expectativa, data = .) %>% 
  summary(.)
```

## Exercício 14

* Determine o número médio, mínimo e máximo do número de citações recebidas em cada uma das revistas onde os artigos científicos foram publicados (dados presentes no objeto __publicacoes).  
* Repita o procedimento acima, mas calcule também o desvio padrão e o número total de artigos publicados em cada revista (utilize a função `n()` para tal).  

## `drop_na`

* Uma das formas de remover as linhas contendo `NA` na `base` do R é através da indexação por lógica, utilizando o `is.na`.
* Você pode fazer a mesma coisa no `tidyverse`, utilizando a função `drop_na` - especificando inclusive de qual coluna você quer que os `NA` sejam removidas.

```{r}
drop_na(data = publicacoes, citacoes)
```

## `separate` {.smaller}

Utilizado para separar as informações de uma coluna em várias colunas diferentes.

```{r}
projetos %>% 
  separate(col = inicio, into = c("dia", "mes", "ano"), sep = "/")
```

## `rownames_to_column`

Por padrão, um `tibble` não comporta nomes nas linhas, o que pode ser particularmente problemático quando convertemos um `data.frame` para àquela classe de objeto. No entanto, podemos usar a função `rownames_to_column` para adicionar uma coluna que contenha o nome de cada linha.

```{r}
varespec <- varespec %>% 
  rownames_to_column(var = "site")
varespec
```


## De largo para longo, e de volta outra vez {#anchor4}

* Uma tarefa que normalmente precisamos fazer é também converter uma tabela do formato largo para o formato longo e vice-versa.
* Além disso, as vezes é mais fácil converter uma tabela para um desses formatos para realizar rapidamente um processamento ou manipulação de dados (e.g., aplicar uma mesma transformação  apenas às colunas que contenham números).
* Existem duas funções que podem nos ajudar nesse sentido:
    + `gather`, para juntar as informações de múltiplas colunas em uma única coluna;
    + `spread`, para espalhar as informações de uma única coluna para múltiplas colunas.

## `gather` {.smaller}

```{r}
formato_longo <- gather(data = varespec, key = "especie", value = "densidade", Callvulg:Cladphyl)
formato_longo
```

## `spread` {.smaller}

```{r eval=FALSE}
formato_largo <- spread(data = formato_longo, key = especie, value = densidade, fill = 0)
formato_largo
```

```{r echo=FALSE}
formato_largo <- tbl_df(spread(data = formato_longo, key = especie, value = densidade, fill = 0))
formato_largo
```

## Exercício 15

* A partir do objeto __formato_longo__, calcule a riqueza de espécies e a abundância total de espécies em cada site.
